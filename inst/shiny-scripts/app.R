

library(shiny)
library(purrr)
library(dplyr)
library(shinycssloaders)
library(shinyFiles)



# Define UI for random distribution app ----
ui <- fluidPage(

  # App title ----
  titlePanel(tags$h1(tags$b("euPredictR: "), "Protein-coding gene sequence
             prediction for novel eukaryotic organisms"),

             ),

  hr(),

  tags$h4(tags$b("Introduction and Biological Context:")),

  tags$p("This app provides a visual interface for the euPredictR package
          in R. The package predicts the protein-coding genes of novel
          eukaroytic organisms based on sequence homology, using raw output
          generated by the Basic Local Alignment
          Search Tool (BLAST)."),

  tags$p("The Basic Local Alignment Search Tool (BLAST) identifies
        high-similarity regions between a 'query' and a 'subject
        sequence. (Altschul et al. 1990) Each shared region of high
        similarity between a query and subject is known as a
        'high-scoring pair' (HSP) and is associated with a score
        known as an 'E-value'. euPredictR analyzes raw BLAST output
         in specific cases where the query sequences are protein-coding
         nucleotide sequences (aka. coding sequences or CDS) for genes
         from some species A, and the subject sequences are contiguous
         reads of a genome from a different species B whose coding
         sequence for the gene has not yet been determined. In this
         context, the parts of the subject sequence within the regions
         of high similarity returned by BLAST are considered by
         euPredictR as potential coding regions comprising the gene for
         species B."),

  tags$p("Taking in raw output from BLAST runs on input coding sequence
         queries and subject genomic sequences, euPredictR determines
         relevant high-scoring pairs, sort out overlaps, and constructs
         new, predicted coding sequence(s) from them."),
  tags$p(tags$b("To begin using the program, follow the input prompts in the
         left sidebar below.")),

  hr(),


  # Sidebar layout with input and output definitions ----
  sidebarLayout(

    # Sidebar panel for inputs ----
    sidebarPanel(

      tabsetPanel(

        tabPanel(

          "Step 1",

          br(),

          tags$p("Before beginning, make sure that you have ran the BLAST
                 algorithm on query coding sequence(s) and subject genomic
                 sequence(s)."),

          fileInput(inputId = "raw_output_file",
                    label = "Select the BLAST output file here. It must be in
                    .json format.",
                    accept = c(".json")),

          shinyDirButton('folder', "Select a folder", "Please select", FALSE),

          verbatimTextOutput("selected_directory") %>%
            withSpinner(color="#0dc5c1",
                        size = 0.5)
        ),

        tabPanel(

          "Step 1: ",

          fileInput(inputId = "raw_output_file2",
                    label = "To begin, select a BLAST output file to predict
                sequences from. File must be in .json format.",
                    accept = c(".json")),


          # Input: maximum intron length
          numericInput(inputId = "max_intron_length",
                       label = "Enter the maximum allowed intron length between
                   exons in a coding sequence predicted by the program. For
                   reference, the median intron length in the human genome is
                   around 1,500 base pairs. (Dvorak et al, 2023)",
                       value = 3000,
                       min = 1),

          # Input: maximum high scoring pairs
          numericInput(inputId = "max_overlap",
                       label = "Enter the maximum allowed overlap between query
                   segments of high scoring pairs (HSPs) used for gene
                   prediction. Although HSPs correspond loosely to an ",
                       value = 30,
                       min = 0
          ),

          # remember to include sample datasets for this (and upload their own
          # data) SPecify the type of data, in extdata

          # br() element to introduce extra vertical spacing ----
          br(),

          actionButton(inputId = "run_button",
                       label = "Run")

        )

      )

    ),

    # Main panel for displaying outputs ----
    mainPanel(

      # Output: Tabset w/ plot, summary, and table ----
      tabsetPanel(type = "tabs",
                  tabPanel("Predicted sequence display",
                           tableOutput("predicted_seqs")),

                  tabPanel("Gene Coverage Heatmap",
                           plotOutput("gene_coverage_heatmap") %>%
                             withSpinner(color="#0dc5c1")),

                  tabPanel("Phylogeny Display",

                           br(),

                           selectInput("gene_selection",
                                       "Select a gene",
                                       choices = c("None detected")),


                           plotOutput("phylogeny_display") %>%
                             withSpinner(color="#0dc5c1")

                           )
      )

    )
  )
)

# Define server logic for random distribution app ----
server <- function(input, output, session) {

  # get the root directory
  volumes <- shinyFiles::getVolumes()()
  # linked to shinyDirButton, selects a file
  shinyFiles::shinyDirChoose(input, 'folder',
                             roots=volumes,
                             filetypes=c('','json'),
                             session=session)

  # converts the directory path into string format
  dirname <- reactive({shinyFiles::parseDirPath(volumes, input$folder)})

  # updates the displayed directory path when it changes
  observe({
    if (!is.null(dirname)){
      output$selected_directory <- renderText(dirname())
    }
  })

  # reactive value for if input directory is valid
  rv <- reactiveValues(valid_input = TRUE)

  # run the json parsing and prediction algorithm if the run button is pressed
  start_prediction <- eventReactive(eventExpr = input$run_button, {

    # catches errors in case the user-inputted directory is in the wrong format
    tryCatch({
      # parse directory containing BLAST output json files
      raw_blast_list <- euPredictR::parse_multiple_BLAST_json(dirname())

      # build predictions based on parsed data
      predictions <- euPredictR::build_predictions(raw_blast_list = raw_blast_list,
                                    max_intron_length = input$max_intron_length,
                                    max_overlap = input$max_overlap)

      # if the program has gotten to this point, no errors
      rv$valid_input = TRUE

      # return the predictions
      predictions
    },
    warning = function(warn){
      showNotification(paste0(warn), type = 'warning')
      rv$valid_input = TRUE
    },
    error = function(err){
      showNotification(paste0(err), type = 'err')
      # if an error happens, invalid input
      rv$valid_input = FALSE
    }
    )
  })

  # if the run button has been pressed and the input is valid, change the
  # available gene options in 'Phylogeny Display'
  observeEvent(input$run_button, {
    if (!is.null(start_prediction) & rv$valid_input){
      total_gene_names <- reduce(lapply(start_prediction(), names), dplyr::union)

      updateSelectInput(session, inputId = "gene_selection",
                        label = "Select a gene",
                        choices = total_gene_names)
    }
  })

  output$gene_coverage_heatmap <- renderPlot({
    if (! is.null(start_prediction) & rv$valid_input)
      euPredictR::gene_coverage_heatmap(predictions = start_prediction())
  })

  output$phylogeny_display <- bindEvent(renderPlot({
    if (! is.null(start_prediction) & rv$valid_input)
      euPredictR::display_phylogeny(predictions = start_prediction(),
                                    gene_name = input$gene_selection)
  }), input$gene_selection)

  output$predicted_seqs <- renderTable({
    if (! is.null(start_prediction) & rv$valid_input)
      euPredictR::output_predictions_df(predictions = start_prediction())
  })

}

# Create Shiny app ----
shinyApp(ui, server)
