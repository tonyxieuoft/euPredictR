# The layout of the app is based on the following Tabsets sample:
# Shiny. (2024). Tabsets. https://shiny.posit.co/r/articles/build/tabsets/
#
# In addition to Shiny, other packages used are cited below:
#
# Attali, D., Edwards, T. (2024). shinyalert: Easily Create Pretty Popup
# Messages (Modals) in 'Shiny'. R package version 3.1.0,
# https://CRAN.R-project.org/package=shinyalert.
#
# Attali, D., Sali, A. (2024). shinycssloaders: Add Loading Animations to a
# 'shiny' Output While It's Recalculating. R package version 1.1.0,
# https://CRAN.R-project.org/package=shinycssloaders.
#
# Pedersen, T., Nijs, V., Schaffner, T., Nantz, E. (2022). shinyFiles: A
# Server-Side File System Viewer for Shiny. R package version 0.9.3,
# https://CRAN.R-project.org/package=shinyFiles.

library(shiny)
library(shinyalert)
library(purrr) # used in this script for its reduce function
library(dplyr) # misc. tools
library(shinycssloaders) # adds a loading button for plots that take longer to
# load
library(shinyFiles) # so that users can select directories and save files

# Define UI for ePredictR
ui <- fluidPage(

  # App title ----
  titlePanel(tags$h1(tags$b("euPredictR: "), "Protein-coding gene sequence
             prediction for novel eukaryotic organisms"),
             ),
  hr(),

  tags$h4(tags$b("Introduction and Biological Context:")),

  tags$p("This app provides a visual interface for the euPredictR package
          in R. The package predicts the protein-coding genes of novel
          eukaroytic organisms based on sequence homology, using raw output
          generated by the Basic Local Alignment
          Search Tool (BLAST)."),

  tags$p("The Basic Local Alignment Search Tool (BLAST) identifies
        high-similarity regions between a 'query' and a 'subject
        sequence. (Altschul et al. 1990) Each shared region of high
        similarity between a query and subject is known as a
        'high-scoring pair' (HSP) and is associated with a score
        known as an 'E-value'. euPredictR analyzes raw BLAST output
         in specific cases where the query sequences are protein-coding
         nucleotide sequences (aka. coding sequences or CDS) for genes
         from some species A, and the subject sequences are contiguous
         reads of a genome from a different species B whose coding
         sequence for the gene has not yet been determined. In this
         context, the parts of the subject sequence within the regions
         of high similarity returned by BLAST are considered by
         euPredictR as potential coding regions comprising the gene for
         species B."),

  tags$p("Taking in raw output from BLAST runs on input coding sequence
         queries and subject genomic sequences, euPredictR determines
         relevant high-scoring pairs, sort out overlaps, and constructs
         new, predicted coding sequence(s) from them."),
  tags$p(tags$b("To begin using the program, follow the input prompts in the
         left sidebar below.")),

  hr(),

  # Sidebar layout with input and output definitions ----
  sidebarLayout(

    # Sidebar panel for inputs ----
    sidebarPanel(

      tabsetPanel(

        tabPanel(

          "Step 1",

          br(),

          tags$p("Before we begin, make sure to run the BLAST
                 algorithm using queries that are coding sequence(s) and subject
                 genomic sequence(s) that are all from a SINGLE species. Do so
                 once for each species you wish to predict
                 coding sequences for. The first word in the fasta heading of
                 each query sequence is assumed to be its gene name."),
          tags$p("Additionally, make
                 sure that all BLAST output files are in", em(".json"),
                 "format, named based on the species that the", em("subject"),
                 "genome represents, and all placed in a", em("single"), "
                 directory that contains no other files or directories."),

          uiOutput("example1"),

          br(),

          uiOutput("example1_drive"),

          br(),

          shinyalert::useShinyalert(force = TRUE),

          tags$p("Here is a detailed explanation of the example dataset: "),

          actionButton(inputId = "data1",
                       label = "Example Dataset Details"),

          br(),

          br(),

          tags$p(tags$b("After making sure the above criteria is met,
                        select the BLAST output directory here:")),
          shinyDirButton('folder', "Directory Upload",
                         "Please select",
                         FALSE,
                         style="background-color:powderblue"),

          verbatimTextOutput("selected_directory") %>%
            shinycssloaders::withSpinner(color="#0dc5c1",
                             size = 0.5),

          br(),

          tags$p("After selecting a valid directory, click on the ",
                 tags$b("Step 2"), "tab.")
        ),

        tabPanel(

          "Step 2",

          br(),

          tags$p("In this section, select custom parameters for the prediction
          algorithm, or stick to the defaults provided. As mentioned in the
          introductory section, the prediction algorithm first identifies relevant",
          em("high scoring pairs,"), " then merges overlaps between them."),

          br(),

          # Input: maximum intron length
          numericInput(inputId = "max_intron_length",
                       label = "Enter the maximum allowed intron length between
                   exons in a coding sequence predicted by the program:",
                       value = 3000,
                       min = 1),

          # Input: maximum high scoring pairs
          numericInput(inputId = "max_overlap",
                       label = "Enter the maximum allowed overlap between query
                   segments of high scoring pairs (HSPs) used for gene
                   prediction.",
                       value = 30,
                       min = 0
          ),
          br(),
          tags$p("Now, click on", tags$b("Step 3.")),
        ),

        tabPanel(
          "Step 3",

          br(),

          tags$p("If you wish for the predicted sequences to be outputted in a
                 fasta file, select the path to the", tags$b("output fasta file"),
                 "here:"),

          shinySaveButton("save", "Select Output Path", "Save file as ...",
                          filetype=list(fasta=c("fasta", "fas"), text="txt")),

          verbatimTextOutput("output_path") %>%
            shinycssloaders::withSpinner(color="#0dc5c1",
                                         size = 0.5),

          br(),

          tags$p("Otherwise, the program will only display the predicted
                 sequences in a panel to the right."),
          br(),
          tags$p(tags$b("Finally, click the button to run the prediction
                        algorithm.")),

          actionButton(inputId = "run_button",
                       label = "Run"),

          br(),
          verbatimTextOutput("fasta_success")
        )
      )
    ),

    # Main panel for displaying outputs ----
    mainPanel(

      # Output: Tabset w/ plot, summary, and table ----
      tabsetPanel(type = "tabs",
                  tabPanel("Predicted sequence display",

                           br(),

                           tags$h4(tags$b("Table of Predicted Coding
                                          Sequences")),

                           tags$p("Instructions: Enter required input in panels
                                  on the left hand size. Then, click",
                                  em('Run'),
                                  "on bottom of the third panel."),

                           tableOutput("predicted_seqs") %>%
                             shinycssloaders::withSpinner(color="#0dc5c1")

                           ),

                  tabPanel("Gene Coverage Heatmap",

                           br(),

                           tags$h4(tags$b("Coverage Heatmap of Predicted
                                          Genes")),

                           tags$p("Instructions: Enter required input in panels
                                  on the left hand size. Then, click",
                                  em('Run'),
                                  "on bottom of the third panel."),

                           tags$p("Colours of the heatmap represent the
                                  proportion of each coding sequence that was
                                  successfully pulled out with BLAST and
                                  predicted by the algorithm. See legend for
                                  precise correspondances."),

                           plotOutput("gene_coverage_heatmap") %>%
                             shinycssloaders::withSpinner(color="#0dc5c1")

                  ),

                  tabPanel("Phylogeny Display",

                           br(),

                           tags$h4(tags$b("Phylogenies Based on Predicted
                                          Genes")),

                           tags$p("Instructions: Enter required input in panels
                                  on the left hand size. Then, click",
                                  em('Run'),
                                  "on bottom of the third panel."),

                           tags$p("Phylogenies are based on the predicted
                                  coding sequences for a single gene.
                                  Relationships are inferred by the
                                  Unweighted Pair Group Method with
                                  Arithmetic Mean (UPGMA). Users should treat
                                  phylogenies as visual displays of predicted
                                  sequence similarity across species, rather
                                  than accurate phylogenetic relationships."),

                           br(),
                           selectInput("gene_selection",
                                       "Select a gene",
                                       choices = c("None detected")),


                           plotOutput("phylogeny_display") %>%
                             shinycssloaders::withSpinner(color="#0dc5c1")

                           )
      )

    )
  )
)


server <- function(input, output, session) {

  # get the root directory
  volumes <- shinyFiles::getVolumes()()
  # linked to shinyDirButton, selects an input directory of raw BLAST output
  shinyFiles::shinyDirChoose(input, 'folder',
                             roots=volumes,
                             filetypes=c('','json'),
                             session=session)

  # linked to shinyFileSave, chooses an output path location for a fasta file
  shinyFiles::shinyFileSave(input, 'save',
                            roots=volumes,
                            session=session)

  # converts the input directory path into string format
  dirname <- reactive({shinyFiles::parseDirPath(volumes, input$folder)})

  # converts the chosen output fasta path intro string format
  output_path <- reactive({shinyFiles::parseSavePath(volumes, input$save)})

  # updates the displayed directory path when it changes
  observe({
    if (!is.null(dirname)){
      output$selected_directory <- renderText(dirname())
    }
  })

  # updates the displayed output filepath when it changes
  observe({
    if (!is.null(output_path)){
      output$output_path <- renderText(output_path()$datapath)
    }
  })

  # reactive value for if input directory is valid
  rv <- reactiveValues(valid_input = TRUE)
  rv2 <- reactiveValues(output_success = FALSE)

  # instantiate a function running the json parsing and prediction algorithm if
  # the run button is pressed
  start_prediction <- eventReactive(eventExpr = input$run_button, {

    # catches errors in case the user-inputted directory is in the wrong format
    tryCatch({
      # parse directory containing BLAST output json files
      raw_blast_list <- euPredictR::parse_multiple_BLAST_json(dirname())

      # build predictions based on parsed data
      predictions <- euPredictR::build_predictions(raw_blast_list =
                                                     raw_blast_list,
                                                   max_intron_length =
                                                     input$max_intron_length,
                                                   max_overlap =
                                                     input$max_overlap)

      # if the program has gotten to this point, no errors
      rv$valid_input = TRUE

      # return the predictions
      predictions
    },
    warning = function(warn){
      showNotification(paste0(warn), type = 'warning')
      rv$valid_input = TRUE
    },
    error = function(err){
      showNotification(paste0(err), type = 'err')
      # if an error happens, invalid input
      rv$valid_input = FALSE
    }
    )
  })

  # every time the run button is pressed, make sure start_prediction() is
  # called so that 'rv$valid_input' is refreshed to indicate whether the
  # current inputted directory is valid or not.
  observeEvent(eventExpr = input$run_button, {
    if (!is.null(start_prediction)){
      start_prediction()
    }
  })

  # if the run button has been pressed, change the
  # available gene options in 'Phylogeny Display'
  observeEvent(input$run_button, {
    if (!is.null(start_prediction)){

      if (rv$valid_input){
        # get available genes
        total_gene_names <- purrr::reduce(base::lapply(start_prediction(), names),
                                          base::union)

        # update the gene selection input in 'Phylogeny Display
        updateSelectInput(session, inputId = "gene_selection",
                          label = "Select a gene",
                          choices = total_gene_names)
      }
      else{
        updateSelectInput(session, inputId = "gene_selection",
                          label = "Select a gene",
                          choices = c("None detected"))
      }
    }
  })

  # create the gene coverage heatmap of the predictions, given valid input
  output$gene_coverage_heatmap <- renderPlot({
    if (! is.null(start_prediction) & rv$valid_input)
      euPredictR::gene_coverage_heatmap(predictions = start_prediction())
  })

  # Create the phylogeny display of each predicted gene, given valid input
  # Do so only when the gene selection is changed
  output$phylogeny_display <- bindEvent(renderPlot({
    if (! is.null(start_prediction) & rv$valid_input)
      euPredictR::display_phylogeny(predictions = start_prediction(),
                                    gene_name = input$gene_selection)
  }), input$gene_selection)

  # output a table of the predicted sequences
  output$predicted_seqs <- renderTable({
    if (! is.null(start_prediction) & rv$valid_input)
      euPredictR::output_predictions_df(predictions = start_prediction())
  })

  observeEvent(input$run_button, {
    if (!is.null(start_prediction) & rv$valid_input &
        length(output_path()$datapath) == 1){
      euPredictR::output_predictions_fasta(predictions = start_prediction(),
                                           output_file = output_path()$datapath)
      output$fasta_success <- renderText("Successfully outputted fasta data!")
    }
    else{
      output$fasta_success <- renderText("")
    }
  })

  # generate a URL to the example dataset
  url1 <- a("Example Dataset (GitHub)", href="https://github.com/tonyxieuoft/euPredictR/blob/master/inst/extdata/example_BLAST_raw_output.zip")
  output$example1 <- renderUI({
    tagList("Here is an example that can be downloaded:", url1)
  })

  # generate another URL (this time to the same file but
  # stored in Google Drive)
  url2 <- a("Example Dataset (Google Drive)", href="https://drive.google.com/file/d/1tdlDX_c1ksVwon42ircb3dCEH-k3uGmy/view?usp=sharing")
  output$example1_drive <- renderUI({
    tagList("If the above link doesn't work, try clicking here:", url2)
  })

  observeEvent(input$data1, {
    shinyalert(title = "Example Dataset",
               text = "A zip file for a directory containing BLAST output .json
               files. The input queries were coding sequences from the
               bottlenose dolphin (T. truncatus) for the genes IL10, IL6,
               TNF, SOX2 and RHO. The subject genomes were from a lamprey (P.
               marinus), zebrafish (D. rerio), common mouse (M. musculus), orca
               (O. orca), and the bottlenose dolphin itself as a control.
               NCBI's blastn was used with the default parameters to obtain the
               results. All sequences are publically available on NCBI; see the
               readME for more details.

               To save the file, click on link, then click Download on the
               top right. Please unzip the file, and select the lowest level
               directory containing the .json files as sample input for the
               program.
               "
               ,
               type = "info",
               html = TRUE)
  })

}

# Create Shiny app ----
shinyApp(ui, server)
