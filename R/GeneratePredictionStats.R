# and then also visualize output, no?


#'
#' Create Heatmap
#'
#' filler description
#'
#' @param predictions Melted dataframe of sequence coverage
#'
#' @import ggplot2
gene_coverage_heatmap <- function(predictions){

  if (!inherits(predictions, "GenePredictions")){
    stop("Incorrect input: 'predictions' must be in GenePredictions
         format and generated by the function build_predictions")
  }

  melted_coverages <- get_gene_coverage(predictions)

  ggplot2::ggplot(melted_coverages, aes(x = species_name,
                                       y = gene_name,
                                       fill = coverage,
                                       width = 0.9,
                                       height = 0.9)) +
    ggplot2::geom_tile() +
    ggplot2::scale_fill_gradient(high = "blue4", low = "cornsilk3")+
    ggplot2::theme(panel.background = element_blank()) +
    ggplot2::xlab("Species Name") +
    ggplot2::ylab("Gene Name") +
    ggplot2::guides(fill=guide_legend(title="CDS coverage"),
                    x = guide_axis(angle = 270))
}

#' Augment Dataset for Heatmap Generation (helper for gene_coverage_heatmap)
#'
#' Given an input GenePredictions object containing predicted coding sequences
#'
#'
#' @param predictions Data frame created by Build Predictions
#'
#' @import purrr
get_gene_coverage <- function(predictions){

  # We get the total, unique gene names by the following:
  # 1) lapply applies the names function to each item in 'predictions'
  # to get the gene names present for each species
  # 2) reduce applies the union operator on the gene names until all
  # are concatenated into a single vector
  total_gene_names <- reduce(lapply(predictions, names), dplyr::union)

  # get species names
  species_names <- names(predictions)

  #
  L <- length(total_gene_names)*length(species_names)

  melted_coverages <- data.frame(species_name = character(length = L),
                                gene_name = character(length = L),
                                coverage = numeric(length = L))

  curr_index <- 1
  for (species in species_names){
    for (gene in total_gene_names){

      seq <- predictions[[species]][[gene]]

      melted_coverages$species_name[curr_index] <- species
      melted_coverages$gene_name[curr_index] <- gene
      if (!is.null(seq)){
        melted_coverages$coverage[curr_index] <- get_coverage(seq)
      }
      else{
        melted_coverages$coverage[curr_index] <- 0
      }
      curr_index = curr_index + 1
    }
  }

  return(melted_coverages)
}


#' Get coverage
#'
#' filler description
#'
#' @param seq The sequence to look for gaps for
#'
#' @import stringr
get_coverage <- function(seq){
  num_gaps <- stringr::str_count(seq, "-")
  seq_length <- nchar(seq)
  return((seq_length - num_gaps)/seq_length)
}


