# Purpose: Build Gene Predictions from parsed BLAST output
# Author: Tony Xie
# Date: 2024-11-27
# Version: 0.1.0
# Bugs and Issues: None

#' Build Gene Predictions from BLAST output data.
#'
#' Given that Basic Local Alignment Search Tool (BLAST) output data has been
#' pre-processed by the parse_BLAST_json
#' or parse_multiple_BLAST_json functions, this function takes in data in
#' RawBlastList format, predicts protein-coding sequences via a dynamic
#' programming algorithm and outputs their sequences in a nested list
#' (elaborated further in the results section). On a high level, for each gene,
#' the prediction algorithm identifies compatible high-scoring pairs (HSPs)
#' with the greatest gene coverage, sorts out overlaps between them, and
#' finally stitches them
#' together to create a new coding sequence (complete or incomplete). Any
#' missing sections of the coding sequence that are unable to be predicted are
#' notated with gaps ("-"). Note that
#' previous assumptions stated for the BLAST-parsing functions hold here as
#' well (the one that states all relevant high-scoring pairs (HSPs) are on the
#' same genomic subject sequence is especially relevant).
#' HSP compatibility (whether two HSPs can fit into the same gene
#' model) is based on the additional assumption that relevant HSPs each loosely
#' correspond to an exon in the gene. From this, we draw the following
#' observations for compatible HSPs 'A' and 'B':
#' \itemize{
#'  \item \emph{Location Linearity}: If the subject segment of 'A' is
#'  before 'B' in the genomic sequence, the query segment of 'A' must
#'  also be before the query segment of 'B'.
#'  \item \emph{Maximum Overlap Restriction}: The query segment for 'A' must
#'  overlap minimally with the query segment for 'B'(a higher threshold above
#'  0 is set for some wiggle room).
#'  \item \emph{Maximum Intron Length}: The subject segment for 'A' must be
#'  somewhat close in proximity to 'B', otherwise the presumed intron between
#'  them would be massively long.
#'  \item \emph{Same Strand}: The subject segment for 'A' must be on the strand
#'  as the subject segment for 'B' (plus/minus).
#' }
#' The maximum intron length and maximum overlap can be modified in the
#' parameter settings of the function. These assumptions are loosely inspired
#' by the Splign algorithm by Kapustin et. al.
#'
#' @param raw_blast_list S3 object of type RawBlastList, containing BLAST output
#' data generated from query coding sequences and subject genomic sequences.
#' @param max_overlap A non-negative integer representing the maximum overlap
#' between the query segments of two compatible HSPs. The default is set to 30.
#' @param max_intron_length A non-negative integer representing the maximum
#' distance between the subject segments of two adjacent, compatible HSPs. The
#' default is set to 50000.
#'
#' @returns Returns an S3 object of type GenePredictions, which is a
#' nested list containing predicted protein-coding sequences with the following
#' structure:
#' \itemize{
#' \item The outer list follows the key-value format,
#' where species names are the keys and each value is a 'gene list' for the
#' species. (just like RawBlastList)
#' \item Each 'gene list' is also a list in key-value format in which each key
#' is a gene name, but differs from the gene lists of RawBlastList in that
#' each value is a predicted sequence in string format. Missing
#' sections of the predicted coding sequence are denoted "-", and are used to
#' visualize gene completeness in later functions.
#' }
#'
#' @examples
#'
#' # Generate gene predictions given an input of sample_raw_blast_list
#' # (see ?sample_raw_blast_list for more details about the dataset).
#' # Max overlap is set to 30, while max intron length is set to 10000 (shorter
#' # introns)
#' predictions <- build_predictions(raw_blast_list = sample_raw_blast_list,
#'                                  max_overlap = 30,
#'                                  max_intron_length = 10000)
#'
#' @export
#'
#' @references
#'
#' Altschul S.F., Gish, W., Miller, W., Myers, E.W. and Lipman, D.J. (1990).
#' Basic local alignment search tool. Journal of Molecular Biology 215(3):
#' 403-410. https://doi.org/10.1016/S0022-2836(05)80360-2
#'
#' Kapustin, Y., Souvorov, A., Tatusova, T. et al. (2008) Splign: algorithms
#' for computing spliced alignments with identification of paralogs. Biol
#' Direct 3: 20. https://doi.org/10.1186/1745-6150-3-20
#'
build_predictions <- function(raw_blast_list,
                              max_overlap=30,
                              max_intron_length=50000){

  if (is.null(raw_blast_list)){
    stop("Invalid input: raw_blast_list cannot be NULL")
  }
  if (!is.null(raw_blast_list) & !inherits(raw_blast_list, "RawBlastList")){
    stop("Invalid input: raw_blast_list must be in RawBlastList format and
         generated by a previous iteration of parse_BLAST_json.")
  }
  else {} # Continue

  if (!is.numeric(max_overlap) | length(max_overlap) > 1 | max_overlap < 0){
    stop("Invalid input: max_overlap must be a non-negative integer")
  }
  else {} # Continue

  if (!is.numeric(max_intron_length) | length(max_intron_length) > 1 |
      max_intron_length < 0){
    stop("Invalid input: max_intron_length must be a non-negative integer")
  }

  # instantiate a list that will be defined as a GenePredictions object later
  predictions <- list()

  # names of represented species to predict sequences for
  species_names <- names(raw_blast_list)

  # iterates along indices corresponding to items where the key is a species
  # name and value is a gene list
  for (i in seq_along(raw_blast_list)){

    # instantiate a new gene list that will hold gene name -> sequence
    # key-value pairs as items
    new_gene_list <- list()

    # list of genes to predict for a particular species
    gene_names <- names(raw_blast_list[[i]])

    # iterates along indices corresponding to items where the key is a gene name
    # and value is a list containing a query's length and its HSP table
    for (j in seq_along(raw_blast_list[[i]])){

      gene <- raw_blast_list[[i]][[j]] # the hsp_table/query_len list

      # Predict a single coding sequence based on the HSP table, for the given
      # gene and species
      predicted_seq <- build_prediction(query_len = gene$query_len,
                                        hsp_table = gene$hsp_data,
                                        max_overlap = max_overlap,
                                        max_intron_length = max_intron_length)

      # add the sequence to our growing gene prediction list (for one species)
      new_gene_list[[gene_names[j]]] <- predicted_seq
    }

    # add the new gene list containing predicted sequences for one species to
    # the overarching predictions list
    predictions[[species_names[i]]] <- new_gene_list

  }
  class(predictions) <- "GenePredictions"
  return(predictions)
}


#' Predict a Single Coding Sequence (helper for build_predictions)
#'
#' Given a data frame of high-scoring pairs (HSPs), length of the query, and
#' various parameters,
#' predict the coding sequence of a gene for a particular species. On a broad
#' level, implements a dynamic programming algorithm (details are in comments)
#' and has the same assumptions as stated in build_predictions.
#'
#' @param hsp_table Data frame, where each row corresponds to an HSP and each
#' column corresponds to the HSP's attributes.
#' @param query_len Length of the query used by BLAST to obtain the HSP table.
#' @param max_overlap Non-negative integer: maximum allowed query segment
#' overlap between compatible HSPs
#' @param max_intron_length Non-negative integer: maximum allowed subject
#' segment distance between compatible HSPs
#'
#' @return Returns the predicted sequence. Missing areas are denoted by "-".
#'
#' @import dplyr
#'
#' @references
#'
#' Kapustin, Y., Souvorov, A., Tatusova, T. et al. (2008) Splign: algorithms
#' for computing spliced alignments with identification of paralogs. Biol
#' Direct 3: 20. https://doi.org/10.1186/1745-6150-3-20
#'
#' Wickham H, François R, Henry L, Müller K, Vaughan D (2023). _dplyr: A
#' Grammar of Data Manipulation_. R package version 1.1.4.
#' https://CRAN.R-project.org/package=dplyr.
#'
build_prediction <- function(query_len,
                             hsp_table,
                             max_overlap,
                             max_intron_length){
  # validity of parameter already checked by build_predictions and previous
  # other functions

  if (is.null(hsp_table)){
    return(NULL)
  }
  else{
    # Continue
  }

  # HSP is first sorted by q_start (the starting index of each HSP's query
  # segment)
  sorted_table <- dplyr::arrange(hsp_table, q_start)

  # Number of HSPs
  num_hsps <- nrow(sorted_table)

  # Instantiate a data frame to store results for the dynamic programming
  # algorithm. Row 'i' in dp corresponds to the 'i'th HSP in the SORTED table.
  # After the DP algorithm completes, dp$coverage[i] is the maximum possible
  # gene coverage using the HSP at position i and only compatible HSPs before
  # it. dp$parent[i] points to the index of the HSP just before i in the
  # optimal set.
  dp <- data.frame(parent = numeric(length = num_hsps),
                   coverage = numeric(length = num_hsps))

  # O(n^2) algorithm, where n is the numer of HSPs
  for (i in 1:num_hsps){

    # default set to no parent (there may be no compatible HSPs before index i
    # with the HSP at index i)
    dp$parent[i] <- -1
    # default coverage set to coverage of the single HSP
    dp$coverage[i] <- sorted_table$seq_len[i]

    max_coverage <- dp$coverage[i]
    for (j in 1:i){

      # if the HSPs at index i and j are compatible (NOTE that the start of the
      # query segment for j is before the start of the query segment for i)
      if (is_compatibile(hsp_table = sorted_table,
                         j = j,
                         i = i,
                         max_overlap = max_overlap,
                         max_intron_length = max_intron_length)){

        # calculate how much the query sequences for HSPs i and j overlap
        overlap_with_j <- max(0,
                              sorted_table$q_end[j] - sorted_table$q_start[i]+1)

        # Based on optimal substructure, the maximum coverage for 'compatible
        # sets including HSP j and HSPs before it' has already been calculated.
        # Therefore, the maximum coverage for 'sets including HSP i and HSPs
        # before it' is the 'maximum coverage for HSP j and HSPs before it'
        # plus the coverage of i, minus their overlap, IF the optimal direct
        # predecessor of i is j.
        new_coverage <- (dp$coverage[j] +
                           sorted_table$seq_len[i] -
                           overlap_with_j)

        # determines if this newly calculated coverage is greater, and updates
        # accordingly
        if (new_coverage > max_coverage){
          max_coverage <- new_coverage
          dp$parent[i] <- j
        }
      }
    }
    dp$coverage[i] <- max_coverage
  }
  # calls on another helper function to create the sequence based on the DP
  # table by tracing the parents.
  return(create_sequence(dp, sorted_table, query_len))
}



#' Determines Compatibility Between Two HSPs (helper for build_prediction)
#'
#' Determines if two high-scoring pairs (HSPs) are compatible, based on the
#' assumptions laid out in build_predictions. Specifically, assumes that
#' relevant HSPs correspond
#' loosely to exons, and therefore must roughly have the same relative
#' attributes that exons do. Loosely inspired by the Splign algorithm by
#' Kapustin et. al.
#'
#' @param hsp_table A data frame of HSPs, sorted in ascending order by query
#' segment start point.
#' @param j Index of HSP with lower query index start point.
#' @param i Index of HSP with higher query index start point.
#' @param max_overlap Maximum allowed overlap between query segments of two
#' compatible HSPs
#' @param max_intron_length Maximum allowed distance between subject segments of
#' compatible HSPs (boundary on allowed intron size)
#'
#' @returns Return True iff HSPs i and j are compatible.
#'
#' @references
#'
#' Kapustin, Y., Souvorov, A., Tatusova, T. et al. (2008) Splign: algorithms
#' for computing spliced alignments with identification of paralogs. Biol
#' Direct 3: 20. https://doi.org/10.1186/1745-6150-3-20
#'
is_compatibile <- function(hsp_table, j, i, max_overlap, max_intron_length){

  # if the query seq for j overlaps with all of i (too much overlap)
  if (hsp_table$q_end[j] >= hsp_table$q_end[i]){
    return(F)
  }
  # if query seq for j overlaps with i by more than ALLOWED_OVERLAP base pairs
  else if (hsp_table$q_end[j] - hsp_table$q_start[i] > max_overlap){
    return(F)
  }
  # if the subject sequences for i and j are not on the same strand
  else if (hsp_table$s_strand[j] != hsp_table$s_strand[i]){
    return(F)
  }
  # check for hsp linearity
  else if (hsp_table$s_start[j] < hsp_table$s_end[j] &
           hsp_table$s_end[j] >= hsp_table$s_start[i]){
    return(F)
  }
  # check for hsp linearity
  else if (hsp_table$s_start[j] > hsp_table$s_end[j] &
           hsp_table$s_end[j] <= hsp_table$s_start[i]){
    return(F)
  }

  # check for hsp subject segment distances breaching maximum intron length
  else if (abs(hsp_table$s_end[j] - hsp_table$s_start[i]) > max_intron_length){
    return(F)
  }
  else{
    return(T)
  }
}

#' Create Sequence from HSP Coverage Dynamic Programming Table (Helper)
#'
#' Creates a predicted sequence based on the dynamic programming table produced
#' earlier. Essentially, the DP table identifies optimal 'sets' of compatible
#' high-scoring pairs (HSPs), and links the optimal HSPs to each other by the
#' 'parent' attribute to
#' get their predecessor. See the comments on the the build_prediction
#' function for more detail. To create the predicted sequence, this function
#' identifies the best "last" HSP in an optimal prediction, then traverses
#' backwards through the predecessors via a recursive helper function to build
#' the prediction up piece by piece.
#'
#' @param dp The dynamic programming table produced earlier by the
#' build_prediction algorithm.
#' @param hsp_table The table of HSPs in SORTED order by the starting index of
#' the query segment.
#' @param query_len Length of the query used to obtain the HSP table. It is
#' assumed that the coding sequence contained within the subject genome should
#' be the same length, and if they're not present in the prediction, then some
#' parts are missing.
#'
#' @return Returns the predicted coding sequence.
#'
create_sequence <- function(dp, hsp_table, query_len){

  # Get the last HSP (by query segment start position) in the optimal set of
  # HSPs
  ending_index <- which.max(dp$coverage)

  # Calls a recursive function to create the sequence
  seq <- recursive_create(dp, hsp_table, ending_index)

  # Sees if there exists a missing portion after the end of the last HSP
  # (nothing corresponding the last segments of the query)
  ending_gap <- strrep("-", query_len - hsp_table$q_end[ending_index])
  return(paste(seq, ending_gap, sep = ""))
}

#' Recursive Helper for create_sequence
#'
#' Outputs a predicted coding sequence ending at HSP i. Recursively calls on
#' itself to trace back through the DP table to get the sequence.
#'
#' @param dp The dynamic programming table, initially created by
#' build_predictions
#' @param hsps The data frame of high scoring pairs, sorted by increasing index
#' for the query segment.
#' @param i Index of the last HSP in the optimal set of HSPs to predict the
#' coding sequence from.
#'
#' @returns The predicted coding sequence when HSP i is the last one in the
#' optimal set.
#'
#' @import stringr
#'
#' @references
#'
#' Wickham H (2023). _stringr: Simple, Consistent Wrappers for
#' Common String Operations_. R package version 1.5.1.
#' https://CRAN.R-project.org/package=stringr.
#'
recursive_create <- function(dp, hsps, i){

  # if the HSP is the first HSP in the optimal chain of HSPs to include
  # (base case)
  if (dp$parent[i] == -1){
    # get the length of the missing segment before it (or zero is the query
    # start is 1)
    missing_beginning <- strrep("-", hsps$q_start[i] - 1)
    # return the sequence
    return(paste(missing_beginning, hsps$s_seq[i], sep = ""))
  }
  else{

    # get it's parent (predecessor) sequence
    p <- dp$parent[i]
    # create the optimal predicted coding sequence as if the predecessor HSP
    # is the last one in the prediction
    seq <- recursive_create(dp, hsps, p)

    # if no overlap exists between HSP i and its predecessor, combine them
    # smoothly
    if (hsps$q_end[p] < hsps$q_start[i]){

      gap <- strrep("-", hsps$q_start[i] - hsps$q_end[p] - 1)
      return(paste(seq, gap, hsps$s_seq[i], sep = ""))
    }
    # otherwise, handle overlaps
    else{
      return(handle_overlap(hsps, seq, p, i))
    }
  }
}


#' High-Scoring Pair (HSP) Overlap Merger (Helper for recursive_create)
#'
#' Minimal algorithm for merging together two overlapping HSPs. If insertions
#' or deletions are present in one of the two overlapping segments, use the
#' subject sequence for the other one for prediction instead. Note that
#' despite the assumption that relevant HSPs correspond loosely to exons, they
#' may still extend extraneously into introns if the intron ends are similar
#' to the neighboring exon ends. This is what likely contributes to the overlaps
#' between HSPs (a personal hypothesis based on observation)
#'
#' @param hsps Dataframe of HSPs, sorted in ascending order by start position of
#' query segment
#' @param seq Currently built sequence by the recursive call in recursive_create
#' @param p Index of parent HSP
#' @param i Index of current HSP in consideration by recursive_create
#'
#' @returns Returns seq and the subject segment of HSP i, merged together as a
#' string
#'
#' @references
#' Wheeler, D. and Bhagwat, M. Blast QuickStart: Example-Driven Web-Based BLAST
#' Tutorial. In: Bergman NH, editor. Comparative Genomics: Volumes 1 and 2.
#' Totowa (NJ): Humana Press; 2007. Chapter 9.
#' https://www.ncbi.nlm.nih.gov/books/NBK1734/
#'
handle_overlap <- function(hsps, seq, p, i){

  # amount of overlap between the two HSPs
  overlap_num <- hsps$q_end[p] - hsps$q_start[i] + 1

  # identifies the lower bound of the overlapping region in the
  # parent sequence. Done this way instead of simple indexing because of a need
  # to consider gaps in the query segment of the HSP.
  num_left <- overlap_num
  p_seq <- hsps$q_seq[p]
  j <- nchar(p_seq)

  while (num_left > 0){
    if (substr(p_seq, j, j) != "-"){
      num_left <- num_left - 1
    }
    else{
      # continue
    }
    j <- j - 1
  }

  seq_low_bound <- nchar(seq) - (nchar(p_seq) - (j + 1))
  seq_overlap <- substr(seq, seq_low_bound, nchar(seq))


  # identifies the upper bound of the overlapping region in
  # HSP i. Done this way instead of simple indexing because of a need
  # to consider gaps in the query segment of the HSP.
  num_right <- overlap_num
  i_seq <- hsps$q_seq[i]
  curr <- 1

  while (num_right > 0){
    if (substr(i_seq, curr, curr) != "-"){
      num_right <- num_right - 1
    }
    else{
      # continue
    }
    curr <- curr + 1
  }

  i_bound <- curr - 1
  i_overlap <- substr(hsps$s_seq[i], 1, i_bound)

  # if the overlapping region of the growing gene prediction (excluding HSP i,
  # so far) doesn't contain gaps, use it as the segment in the overlapping
  # section and remove the other.
  if (stringr::str_count(seq_overlap, "-") == 0){
    i_to_take <- substr(hsps$s_seq[i], i_bound + 1, nchar(hsps$s_seq[i]))
    return(paste(seq, i_to_take, sep = ""))
  }
  else{
    # Otherwise, use all of HSP i's subject segment in the gene prediction to
    # override the overlap
    seq_to_take <- substr(seq, 1, seq_low_bound-1)
    return(paste(seq_to_take, hsps$s_seq[i], sep = ""))
  }
}

# [END]
